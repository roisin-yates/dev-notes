<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../main.css" type="text/css">
  <script src="../script.js" defer></script>
  <title>Roisin's Notes</title>
</head>

<body>
<header>
  <h1>Roisin's Notes</h1>
  <nav>
    <ul class="nav-links">
      <a href="../index.html">Home</a>
      <a href=""><li>HMTL</li></a>
      <a href=""><li>CSS</li></a>
      <a href=""><li>JS</li></a>
    </ul>
  </nav>
</header>

<div class="article-body">
  <h2>Array Methods</h2>

  <div class="article-info">
    <p>Let's begin with the array: <code>const fruits = ['banana', 'orange', 'apple']</code></p>
    <hr>

    <h3>.pop()</h3>
    <h4>Practical use cases:</h4>
    <ul class="article-list">
      <li>No longer need the last element of an array/ Remove the last element</li>
      <li>Return the last element</li>
      <li>Managing a stack of items (last in, first out)</li>
      <li>Processing data in reverse order - getting the last elements one by one</li>
      <li>Implementing undo/redo</li>
    </ul>
    <p>
      Removes the last element from an array: <code> fruits.pop()</code> returns the array <code>'banana', 'orange'</code>
    </p>
    <p>
      Can return the removed element by assigning it to a variable: <code>let fruit = fruits.pop()</code>, returns 'apple'
    </p>
    <h4>Pros & cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <p class="bold">Pros</p>
        <ul>
          <li>Simple efficient way to remove last element of array</li>
          <li>Modifies the original array, no need to create new array. More memory efficient</li>
          <li>Returns the element that was removed, can be useful if you need to store that value</li>
        </ul>
      </div>
      <div class="pros-cons">
        <p class="bold">Cons</p>
        <ul>
          <li>Only removes the last element, would have to use <span class="bold">.shift()</span> or <span class="bold">.splice()</span>
          to remove from the middle or beginning</li>
          <li>Need to call multiple times for multiple elements</li>
        </ul>

      </div>
    </div>
    <hr>

    <!-- PUSH() -->
    <h3>.push()</h3>
    <p>One of the more commonly used</p>
    <h4>Practical use cases:</h4>
    <ul class="article-list">
      <li>Adding elements to an array in chronological order</li>
      <li>Building a queue of items (FIFO - first in, first out)</li>
      <li>Creating a new array from scratch</li>
      <li>Combining arrays *</li>
    </ul>
    <p>
      Adds a new element to an array at the end: <code>fruits.push('passionfruit')</code> adds passionfruit to fruits[3]
    </p>
    <p>
      Can return the length of the array with the new element: <code>let length = fruits.push('passionfruit')</code>, returns 4
    </p>
    <h4>* Difference between .push() and .concat()</h4>
    <p>
      When combining arrays, <span class="bold"> .concat()</span> returns a new array the contains the elements of the old arrays, while
      <span class="bold"> .push()</span> modifies the original array by adding a different array to it.
    </p>
    <h4>Pros & cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <ul>
          <p class="bold">PROS</p>
          <li>Modifies the original array in place, more memory efficient than <span class="bold"> .concat()</span></li>
          <li>Flexible, allows you to add multiple elements</li>
          <li>Simple way to add elements - which is a common operation</li>
        </ul>
      </div>
      <div class="pros-cons">
        <ul>
          <p class="bold">CONS</p>
          <li>Only allows you to add elements to end of array. <span class="bold">.unshift()</span>  or <span class="bold">.splice()</span>  can be used to place in other indexes</li>
          <li>If working with large arrays, adding elements to end can be slow - have to iterate over entire array to find end</li>
        </ul>
      </div>
    </div>
    <hr>
    
    <!-- SPLIT() -->
    <h3>.split()</h3>
    <h4>Practical use cases:</h4>
    <ul class="article-list">
      <li> <a href="./glossary.html#parsing" class="bold">Parsing</a> data, useful for processing data in a CSV(comma separated values) file</li>
      <li>Working with URLs - can split URL intp protocol, host and path</li>
      <li>Removing characters, then use .join() to turn back into string</li>
      <li>Tokenizing input: turning search queries into array of keywords</li>
    </ul>
    <p>
      Splits a string into an array of substrings: For example the string <code> let fruitString = 'Hello there I like fruit'</code>, when called as 
      <code>let fruitArray = fruitString.split(' ') </code> returns <code>['Hello','there','I','like','fruit']</code>
    </p>
    <p>
      Can limit the return to a certain number of words with second parameter: <code>let fruitArray = fruitString.split(' ', 3) </code>:
      returns <code>['Hello','there','I']</code>
    </p>
    <h4>Pros & cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Pros
          </p>
          <li>Simple and easy to use</li>
          <li>Used to extract specific parts of a string</li>
          <li>Can be used to remove specific characters or patters by splitting and rejoining</li>
        </ul>
      </div>
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Cons
          </p>
          <li>Slow and memory-intensive for large strings as creates a new array in memory for each substring. <a href="./glossary.html#regular-expressions" class="bold">Regular expressions</a>  may be
            less memory intensive if you don't need to create a new array.
          </li>
          <li>Can be error prone if separator is not well-defined</li>
          <li>Not the most efficient way of parsking tasks, like XML or JSON</li>
        </ul>
      </div>
    </div>
    <hr>

    <!-- MAP -->
    <h3>.map()</h3>
    <h4>Practical use cases:</h4>
    <ul class="article-list">
      <li>Transforming an array: Modifying each element in the array.</li>
      <li>Extracting data: returning a new array with desired conditions.</li>
      <li>Converting data types: transforming every element.</li>
      <li>Creating a new array with different values.</li>
    </ul>
    <p>
      <a href="./glossary.html#higher-order" class="bold">Higher order function.</a>  Rearranges the array by iterating through each element and applying a given function to each element, 
      returning a new array with the modified elements.
    </p>
    <h4>Syntax:</h4>
    <p>
      <code>array.map(function(element, index, array) {
        <br> //code the be executed
        <br> }, argument)
      </code>
    </p>
    <p>
      For example, to create a new array with numbers from an existing array doubled:
      <br><code> let newArray = array.map((num) => {
      <br> return num * 2
      <br> })</code>
    </p>
    <h4>Pros & Cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Pros
          </p>
          <li>Simplified version of a loop for arrays</li>
          <li>A  <a href="./glossary.html#pure-functions" class="bold">pure function</a> . Creates a new array without modifying the original</li>
          <li>Supports <a href="./glossary.html#chaning" class="bold">chaining</a></li>
        </ul>
      </div>
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Cons
          </p>
          <li>Creating a new array can be less efficient than modifying the original array</li>
          <li>Not suited for all situations</li>
          <li>Can be difficult to debug due to being higher order function</li>
        </ul>

      </div>

    </div>
    <hr>

    <!-- .REDUCE() -->
    <h3>.reduce()</h3>
    <h4>Practical use cases</h4>
    <ul class="article-list">
      <li>summing an array of numbers - useful for calculating total of shopping cart or score in game</li>
      <li>Finding the maximum or minimum value</li>
      <li>Counting the occurances of values in an array</li>
      <li>Flattening nested arrays</li>
    </ul>
    <p>
      Reduces an array down into a single value by applying a function to each element of the array, accumulating a result that is passed
      from one iteration to the next. For example, you may have an array of objects, each with a price. The .reduce() method can return a 
      single, total price.
    </p>
    <h4>Syntax</h4>
    <p>
      Takes 2 different parameters:
    </p>
    <ol class="article-list">
      <li>A function: <code>array.reduce(<span class="bold">() => {
        <br> }</span>,0)
      </code></li>
      <li>and the initial value: <code>array.reduce(() => {
        <br>} <span class="bold">,0</span>)
      </code></li>
    </ol>
    <p>
      The arrow function then takes 2 different parameters: 
    </p>
    <ol class="article-list">
      <li>The accumulator: What we're trying to reduce the array into</li>
      <li>The items: each individual item that we're looping through</li>
    </ol>
    <p>
      Deep dive properly <a href="https://www.youtube.com/watch?v=s1XVfm5mIuU" class="bold">here</a>
    </p>
    <h4>Pros & Cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Pros
          </p>
          <li>Flexible and versitile </li>
          <li>Concise</li>
          <li>Fast</li>
          <li>Maintainable</li>
        </ul>
      </div>
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Cons
          </p>
          <li>Difficult for beginners</li>
            <li>Complex and more difficult to read and debug in some cases</li>
            <li>Slower than a for loop if using a small array</li>
        </ul>
      </div>
    </div>
    <hr>

    <!-- .FIND() -->
    <h3>.find()</h3>
    <p>
      Finds the first item in an array that matches conditions. Takes a <a href="./glossary.html#callback" class="bold">callback function</a>  as its argument, which is called on each
      element until a match is found. The method returns that match and stops.
    </p>
    <h4>Syntax</h4>
    <p>
      <code>let newArray = array.find((item) => {
          <br> argument })
      </code>
    </p>
    <h4>Pros & Cons</h4>
    <div class="diagrams">
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Pros
          </p>
          <li>More efficient than searching through entire array as stops once the condition matches</li>
          <li>Uses a callback to define the condition - flexibility and control</li>
          <li>returns undefined in no elements match, good for <a href="./glossary.html#error-handling" class="bold"> error handling</a> </li>
        </ul>
      </div>
      <div class="pros-cons">
        <ul>
          <p class="bold">
            Cons
          </p>
          <li>Only returns the first matching element</li>
          <li>Confusing for those not familiar with callback functions</li>
        </ul>
      </div>
    </div>
    <hr>

    <!-- .JOIN() -->
    <h3>.join()</h3>
    <p>
      Returns an array as a string without affecting the original array.
    </p>
    <h4>Syntax</h4>
    <p>
      <code>array.join(separator)</code>
    </p>
    <hr>


    <!-- .SHIFT() -->
    <h3>.shift()</h3>
    <p>
      Removes the first element in an array and shifts the other elements down an index: <code>fruits.shift()</code>, 
      removes 'banana', 'orange' becomes fruits[0]
    </p>
    <p>
      Can return the element that was shifted: <code>let fruit = fruits.shift()</code>, returns 'banana'
    </p>
    <hr>

    <!-- UNSHIFT() -->
    <h3>.unshift()</h3>
    <p>
      Adds a new element to an array array at the 0 index, pushing other elements back an index: <code>fruits.unshift('passionfruit')        
      </code>, adds 'passionfruit' as fruits[0], and 'banana' becomes fruits[1]
    </p>
    <p>
      Returns the length of the array with the unshifted elements: <code>let length = fruits.unshift('passionfruit')</code>,
      returns 4.
    </p>
    <hr>

    <!-- .CONCAT() -->
    <h3>.concat()</h3>
    <p>
      Concatenates a new array (creates a new array by merging existing arrays). Say we have a second array: <code>let veggies = 
        ['broccoli', 'lettuce', 'tomato']
      </code> using .concat with can merge with fruits: <code>let 5ADay = fruits.concat(veggies)</code>, will return 5ADay as <code>
        ['banana', 'orange', 'apple', 'broccoli', 'lettuce', 'tomato'].</code> 
    </p>
    <p>
      The array the .concat() method is called on will come first, and the array in brackets will come after.
    </p>
    <hr>

    <!-- .SPLICE() -->
    <h3>.splice()</h3>
    <p>
      Adds new items to an array. The first parameter defines the index where the element should be added, the second defines how many
      elements to remove, the rest defines the elements to be added.
    </p>
    <p>
      <code>fruits.splice(2, 0, 'passionfruit')</code>: adds 'passionfruit' to the 2 index (3rd place) and removes 0 elements.
    </p>
    <p>
      <code>fruits.splice(0,2)</code>: Adds 0 elements, but the first two elements in an array are removed without leaving 'undefined'.
    </p>
    <hr>

    <!-- .SLICE() -->
    <h3>.slice()</h3>
    <p>
      Slices out a piece of an array into a new array: <code>let newArray = fruits.slice(1, 3)</code>: Returns a new array with
      fruits from index 1 - 3
    </p>
    <p>
      <code>let newArray = fruits.slice(2)</code>: with only one parameter the new array will slice out all elements from index 2 and above.
    </p>
    <hr>

    <!-- .TOSTRING() -->
    <h3>.toString()</h3>
    <p>
      Converts an array to a comma separated string without affecting the current array.
    </p>
    <hr>

    <!-- .EVERY() -->
    <h3>.every()</h3>
    <p>Iterates through every array object and returns true if all elements return true, or false if one element returns false. It ignores
      empty elements.
    </p>
    <h4>Syntax</h4>
    <p>
      Must take a callback function, which can take 3 parameters. Can also take an optional second parameter alongside the callback function
    </p>
    <p>
      <code>array.every((currentValue, index, arr) => {
        <br>}, thisValue)
      </code>
    </p>
    <hr>

    <!-- .FILTER() -->
    <h3>.filter()</h3>
    <p>
      Creates a new array filled with elements that pass a test within a callback function. Ignores empty elements and does not change 
      the original array. If no items pass, it returns an empty array.
    </p>
    <h4>Syntax</h4>
    <p>
      <code>array.filter((currentValue, index, arr) => {
        <br>}, thisValue)
      </code>
    </p>
    <hr>

    <!-- .REVERSE() -->
    <h3>.reverse()</h3>
    <p>
      Reverses the order of an array directly, not creating a new array but overwriting the original. Called within a function or 
      globally without a variable.
    </p>


    
  </div>

</div>


</body>


</html>